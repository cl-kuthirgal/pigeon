#+TITLE: pigeon

A toy S-EXP (a particular flavor) to python transpiler in the spirit of [[https://github.com/burtonsamograd/sxc][sxc]]. The
plan is to exploit the macro system of common lisp to emit plain python source
(not vm bytecode). Most of the useful stuff will go as regular lisp [[Macros][macros]].

#+BEGIN_SRC lisp :exports both
  (pgfmt '(defun hello-world (name)
           (print (+ "hello " name))))
#+END_SRC

#+RESULTS:
: def hello_world(name):
:     print(("hello " + name))

#+BEGIN_SRC lisp :exports both
  (pgfmt
   '(progn
     (import (numpy :as np))

     (defun random (size)
       (np.random.rand size size))

     (setf a "hello")

     (print a)))
#+END_SRC

#+RESULTS:
: import numpy as np
: def random(size):
:     np.random.rand(size, size)
: a = "hello"
: print(a)

* Features

** Types
#+BEGIN_SRC lisp :exports both
  (pgfmt
   '(progn
     t                              ;; True
     f                              ;; False
     none                           ;; None
     (setf some-array #(1 2 3 5))   ;; lisp type vectors go as numpy array

     (setf some-list (list 12 2 3)) ;; regular lists go as python lists

     (setf some-dict (dict "a" "world" "b" "hello"))

     (setf some-tuple (tuple 1 2))))
#+END_SRC

#+RESULTS:
: True
: False
: None
: some_array = np.array([1, 2, 3, 5])
: some_list = [12, 2, 3]
: some_dict = {"a": "world", "b": "hello"}
: some_tuple = (1, 2)

*** TODO Inline constants

** Lambdas

#+BEGIN_SRC lisp :exports both
  (pgfmt
   '(progn
     (fn "lol kek")
     (fn-xy (+ x y))
     (fn-abc (+ a b (/ 2 c)))))
#+END_SRC

#+RESULTS:
: (lambda : "lol kek")
: (lambda x, y: (x + y))
: (lambda a, b, c: (a + b + (2 / c)))

** TODO Conditionals and loops

** TODO Contexts

** Macros
Pigeon uses usual lisp macros loaded from a ~.pgl~ files using ~pigeon::load-pgl~.
Macro expansion works on the pigeon code before converting to python.

** TODO Quasiquotes

** TODO Arrows

** TODO Some stupid stuff
