#+TITLE: pigeon

A toy S-EXP (a particular flavor) to python transpiler in the spirit of [[https://github.com/burtonsamograd/sxc][sxc]]. The
plan is to exploit the macro system of common lisp to emit plain python source
(not vm bytecode). Most of the useful stuff will go as regular lisp [[Macros][macros]].

#+BEGIN_QUOTE
For a practical python-lisp, see [[https://github.com/hylang/hy][hy]].
#+END_QUOTE

* Building

/Don't use the binary version, it doesn't work for all the cases. Just run the
repl./

#+BEGIN_SRC sh
lake build
./bin/pigeon <input-file> <output-path>
#+END_SRC

* Quickstart

#+BEGIN_SRC lisp :exports both
  (pgfmt
   (import (numpy :as np))

   (defun random (size)
     (np.random.rand size size))

   (setf a "hello")
   (print a))
#+END_SRC

#+RESULTS:
: import numpy as np
: 
: def random(size):
:     return np.random.rand(size, size)
: 
: a = "hello"
: 
: print(a)

* Features

** Types
#+BEGIN_SRC lisp :exports both
  (pgfmt
   t                              ;; True
   f                              ;; False
   none                           ;; None
   (setf some-array #(1 2 3 5))   ;; lisp type vectors go as numpy array

   (setf some-list [12 2 3])      ;; hy style lists go as python lists

   (setf some-dict (dict "a" "world" "b" "hello"))

   (setf some-tuple (tuple 1 2)))
#+END_SRC

#+RESULTS:
#+begin_example
True

False

None

some_array = np.array([1, 2, 3, 5])

some_list = [12, 2, 3]

some_dict = {"a": "world", "b": "hello"}

some_tuple = (1, 2)
#+end_example

*** TODO Inline constants

** Lambdas

#+BEGIN_SRC lisp :exports both
  (pgfmt
   (fn "lol kek")
   (fn-xy (+ x y))
   (fn-abc (+ a b (/ 2 c))))
#+END_SRC

#+RESULTS:
: (lambda : "lol kek")
: 
: (lambda x, y: (x + y))
: 
: (lambda a, b, c: (a + b + (2 / c)))

** TODO Conditionals and loops

#+BEGIN_SRC lisp :exports both
  (pgfmt
   (cond ((this-thing) (then-that))
         ((another-thing) (another-that))
         (t fallback)))
#+END_SRC

#+RESULTS:
: if this_thing():
:     then_that()
: elif another_thing():
:     another_that()
: else:
:     fallback

#+BEGIN_SRC lisp :exports both
  (pgfmt @[(+ x x) :for x :in (range 10) :if (evenp x)])
#+END_SRC

#+RESULTS:
: [(x + x) for x in range(10) if evenp(x)]

If you are doing a ~setf~ with a ~loop~, you should get a list comprehension
unconditionally. Otherwise, we will run it as the regular indented loop.

#+BEGIN_SRC lisp :exports both
  ;; NOTE: These are not implemented as of now
  ;; regular for loop
  (pgfmt
   '(loop for var in exp do
     stuff
     stuff-2))

  ;; regular for loop with results collected in a list
  (pgfmt
   '(loop for var in exp collect stuff stuff-2))

  (pgfmt
   '(loop for var in exp
     if condition
     collect value))

  (pgfmt
   '(loop for var in exp
     if condition
     collect-dict key value))

  (pgfmt
   '(loop for var in exp
     if condition
     collect-set value))

  (pgfmt
   '(loop for var in exp
     if condition
     collect-gen value))

  (pgfmt
   '(loop while exp do
     stuff
     stuff-2))
#+END_SRC

** TODO Contexts

** Macros
Pigeon uses usual lisp macros loaded from a ~.pgl~ files using ~pigeon::load-pgl~.
Macro expansion works on the pigeon code before converting to python.

** Imports
#+BEGIN_SRC lisp :exports both
  (pgfmt
   (import numpy :as np)
   (import (kek :as lol) :from lel)
   (import (this :as that) (who :as whom)))
#+END_SRC

#+RESULTS:
: import numpy
: import as
: import np
: 
: from lel import kek as lol
: 
: import this as that
: import who as whom

** IDs
To use case sensitive python ids, use ~#i~ reader macro:

#+BEGIN_SRC lisp :exports both
  (pgfmt
   (setf #iTHisIsSick 343)
   (import #iLastFm))
#+END_SRC

#+RESULTS:
: THisIsSick = 343
: 
: import LastFm

** TODO Quasiquotes

** TODO Arrows

** TODO Some stupid stuff
